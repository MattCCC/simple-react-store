{"version":3,"sources":["../src/store.tsx"],"sourcesContent":["import { useReducer, useMemo, FC, PropsWithChildren } from 'react';\n\nimport { createContext, useContextSelector } from 'use-context-selector';\nimport { Action, Actions, Funct, Mutations, Store, ValueOf } from './types/store';\n\n/**\n * Toggle state boolean\n * @param {string} type      State key\n * @returns {object}        Modified state\n * @deprecated You can set the state directly without using the wrapper\n */\nexport function set<T, T1, T2 = T>(type: keyof T): Funct<T2, T1> {\n  return (prevState, payload): unknown => ({\n    ...prevState,\n    [type]: payload,\n  });\n}\n\nfunction makeInitialActions<S, M extends Mutations<S>>(mutations: M): Actions<M> {\n  const actions: Actions<M> = Object.assign({}, mutations);\n\n  Object.keys(mutations).forEach((name: keyof M) => {\n    actions[name] = (): void => {};\n  });\n\n  return actions;\n}\n\n/**\n * Create a simple store instance with the initial state and reducer\n * @param initialState      Initial store state\n * @param reducer           Reducer to mutate state\n * @returns {Store}         Store instance with `Provider` component and `useStore` hook\n */\nexport function createStore<S, M extends Mutations<S>>(\n  initialState: S,\n  mutations: M\n): Store<S, M> {\n  const defaultContext: [S, Actions<M>] = [\n    initialState,\n    makeInitialActions<S, M>(mutations),\n  ];\n  const context = createContext(defaultContext);\n  let actions: Actions<M> | null = null;\n\n  function reducer(\n    prevState: S,\n    action: Action<M>\n  ): S {\n    const mutationResult = mutations[action.type](prevState, ...action.payload as unknown[]);\n\n    if (typeof mutationResult !== \"object\" || mutationResult === null) {\n      return {\n        ...prevState,\n      };\n    }\n\n    return {\n      ...prevState,\n      ...mutationResult,\n    };\n  }\n\n  function Provider({ children }: PropsWithChildren) {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    actions = useMemo(() => {\n      const result: Actions<M> = Object.assign({}, mutations);\n\n      Object.keys(mutations).forEach((type: keyof M) => {\n        result[type] = (...args) => {\n          dispatch({ type, payload: args });\n        };\n      });\n\n      return result;\n    }, [dispatch]);\n\n    const contextValue = useMemo(\n      () => [state, actions] as [S, Actions<M>],\n      [state, actions]\n    );\n\n    return <context.Provider value={contextValue}>{children}</context.Provider>;\n  }\n\n  function useStore() {\n    return useContextSelector(context, (state) => state);\n  }\n\n  function useStoreProp<K extends keyof S>(prop: K): [S[K], Actions<M>] {\n    const value = useContextSelector(context, (state) => state[0][prop]);\n\n    return [value, actions];\n  }\n\n  return { Provider, useStore, useStoreProp };\n}\n\n/**\n * A custom hook to combine multiple stores and returns a single Provider.\n * @param stores List of stores\n * @returns A single Provider component that provides all the stores\n */\nexport function useStoreProvider(\n  ...stores: Array<Store<unknown, unknown>>\n): FC<PropsWithChildren<Record<string, unknown>>> {\n  function Provider({ children }: PropsWithChildren) {\n    let wrapped = children;\n\n    stores.forEach(({ Provider: ProviderWrapper }) => {\n      wrapped = <ProviderWrapper>{wrapped}</ProviderWrapper>;\n    });\n\n    return <>{wrapped}</>;\n  }\n\n  return Provider;\n}\n\n/**\n * Merge State while preserving initial state's sub-objects\n * @param key State property\n * @param initialState Initial state\n * @param prevState Previous state\n * @param obj New object to be updated\n * @returns Merged object\n * @deprecated You can create your own tailored wrapper if required\n */\nexport function mergeState<State = { [x: string]: unknown }>(\n  key: keyof State,\n  initialState: State,\n  prevState: State,\n  obj: Partial<ValueOf<State, typeof key>> | undefined\n): State {\n  return { ...prevState, ...{ [key]: { ...initialState[key], ...prevState[key], ...obj } } };\n}\n"],"mappings":"AAAA,OAAS,cAAAA,EAAY,WAAAC,MAAsC,QAE3D,OAAS,iBAAAC,EAAe,sBAAAC,MAA0B,uBAiFvC,OA+BA,YAAAC,EA/BA,OAAAC,MAAA,oBAxEJ,SAASC,EAAmBC,EAA8B,CAC/D,MAAO,CAACC,EAAWC,KAAsB,CACvC,GAAGD,EACH,CAACD,CAAI,EAAGE,CACV,EACF,CAEA,SAASC,EAA8CC,EAA0B,CAC/E,IAAMC,EAAsB,OAAO,OAAO,CAAC,EAAGD,CAAS,EAEvD,cAAO,KAAKA,CAAS,EAAE,QAASE,GAAkB,CAChDD,EAAQC,CAAI,EAAI,IAAY,CAAC,CAC/B,CAAC,EAEMD,CACT,CAQO,SAASE,EACdC,EACAJ,EACa,CACb,IAAMK,EAAkC,CACtCD,EACAL,EAAyBC,CAAS,CACpC,EACMM,EAAUf,EAAcc,CAAc,EACxCJ,EAA6B,KAEjC,SAASM,EACPV,EACAW,EACG,CACH,IAAMC,EAAiBT,EAAUQ,EAAO,IAAI,EAAEX,EAAW,GAAGW,EAAO,OAAoB,EAEvF,OAAI,OAAOC,GAAmB,UAAYA,IAAmB,KACpD,CACL,GAAGZ,CACL,EAGK,CACL,GAAGA,EACH,GAAGY,CACL,CACF,CAEA,SAASC,EAAS,CAAE,SAAAC,CAAS,EAAsB,CACjD,GAAM,CAACC,EAAOC,CAAQ,EAAIxB,EAAWkB,EAASH,CAAY,EAE1DH,EAAUX,EAAQ,IAAM,CACtB,IAAMwB,EAAqB,OAAO,OAAO,CAAC,EAAGd,CAAS,EAEtD,cAAO,KAAKA,CAAS,EAAE,QAASJ,GAAkB,CAChDkB,EAAOlB,CAAI,EAAI,IAAImB,IAAS,CAC1BF,EAAS,CAAE,KAAAjB,EAAM,QAASmB,CAAK,CAAC,CAClC,CACF,CAAC,EAEMD,CACT,EAAG,CAACD,CAAQ,CAAC,EAEb,IAAMG,EAAe1B,EACnB,IAAM,CAACsB,EAAOX,CAAO,EACrB,CAACW,EAAOX,CAAO,CACjB,EAEA,OAAOP,EAACY,EAAQ,SAAR,CAAiB,MAAOU,EAAe,SAAAL,EAAS,CAC1D,CAEA,SAASM,GAAW,CAClB,OAAOzB,EAAmBc,EAAUM,GAAUA,CAAK,CACrD,CAEA,SAASM,EAAgCC,EAA6B,CAGpE,MAAO,CAFO3B,EAAmBc,EAAUM,GAAUA,EAAM,CAAC,EAAEO,CAAI,CAAC,EAEpDlB,CAAO,CACxB,CAEA,MAAO,CAAE,SAAAS,EAAU,SAAAO,EAAU,aAAAC,CAAa,CAC5C,CAOO,SAASE,KACXC,EAC6C,CAChD,SAASX,EAAS,CAAE,SAAAC,CAAS,EAAsB,CACjD,IAAIW,EAAUX,EAEd,OAAAU,EAAO,QAAQ,CAAC,CAAE,SAAUE,CAAgB,IAAM,CAChDD,EAAU5B,EAAC6B,EAAA,CAAiB,SAAAD,EAAQ,CACtC,CAAC,EAEM5B,EAAAD,EAAA,CAAG,SAAA6B,EAAQ,CACpB,CAEA,OAAOZ,CACT,CAWO,SAASc,EACdC,EACArB,EACAP,EACA6B,EACO,CACP,MAAO,CAAE,GAAG7B,EAAgB,CAAC4B,CAAG,EAAG,CAAE,GAAGrB,EAAaqB,CAAG,EAAG,GAAG5B,EAAU4B,CAAG,EAAG,GAAGC,CAAI,CAAI,CAC3F","names":["useReducer","useMemo","createContext","useContextSelector","Fragment","jsx","set","type","prevState","payload","makeInitialActions","mutations","actions","name","createStore","initialState","defaultContext","context","reducer","action","mutationResult","Provider","children","state","dispatch","result","args","contextValue","useStore","useStoreProp","prop","useStoreProvider","stores","wrapped","ProviderWrapper","mergeState","key","obj"]}