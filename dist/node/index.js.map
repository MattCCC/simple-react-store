{"version":3,"sources":["../src/index.ts","../src/store.tsx"],"sourcesContent":["export * from './store';\nexport * from './types/store';","import { useReducer, useMemo, FC, PropsWithChildren } from 'react';\n\nimport { createContext, useContextSelector } from 'use-context-selector';\nimport { Actions, Funct, Mutations, Payload, Store } from './types/store';\n\n/**\n * Toggle state boolean\n * @param {string} type      State key\n * @returns {object}        Modified state\n */\nexport const set =\n  <T, T1, T2 = T>(type: keyof T): Funct<T2, T1> =>\n  (prevState, payload): any => ({\n    ...prevState,\n    [type]: payload,\n  });\n\nfunction getEmptyActions<S, M extends Mutations<S>>(mutations: M): Actions<M> {\n  const actions: Actions<M> = Object.assign({}, mutations);\n\n  Object.keys(mutations).forEach((name: keyof M) => {\n    actions[name] = (): void => {};\n  });\n\n  return actions;\n}\n\n/**\n * Create a simple store instance with the initial state and reducer\n * @param initialState      Initial store state\n * @param reducer           Reducer to mutate state\n * @returns {Store}         Store instance with `Provider` component and `useStore` hook\n */\nexport function createStore<S, M extends Mutations<S>>(\n  initialState: S,\n  mutations: M\n): Store<S, M> {\n  const context = createContext([\n    initialState,\n    getEmptyActions<S, M>(mutations),\n  ]);\n  let actions: Actions<M> | null = null;\n\n  function reducer(\n    prevState: S,\n    action: {\n      type: keyof M;\n      payload: Payload<M[keyof M]>;\n    }\n  ): S {\n    return {\n      ...prevState,\n      ...mutations[action.type](prevState, ...(action.payload as unknown[])),\n    };\n  }\n\n  function Provider({\n    children,\n  }: PropsWithChildren<Record<string, unknown>>) {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    actions = useMemo(() => {\n      const result: Actions<M> = Object.assign({}, mutations);\n\n      Object.keys(mutations).forEach((name: keyof M) => {\n        result[name] = (...args): void => {\n          dispatch({ type: name, payload: args });\n        };\n      });\n\n      return result;\n    }, [dispatch]);\n\n    return (\n      <context.Provider value={[state, actions]}>{children}</context.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContextSelector(context, (state) => state);\n  }\n\n  function useStoreProp(prop: keyof M) {\n    const state = useContextSelector(\n      context,\n      (v) => (v[0] as Actions<M>)[prop]\n    );\n\n    return [state, actions];\n  }\n\n  return { Provider, useStore, useStoreProp } as any;\n}\n\n/**\n * A custom hook to combine multiple stores and returns a single Provider.\n * @param stores List of stores\n * @returns A single Provider component that provides all the stores\n */\nexport function useStoreProvider(\n  ...stores: Array<Store<any, any>>\n): FC<PropsWithChildren<Record<string, unknown>>> {\n  function Provider({\n    children,\n  }: PropsWithChildren<Record<string, unknown>>) {\n    let wrapped = children;\n\n    stores.forEach(({ Provider: ProviderWrapper }) => {\n      wrapped = <ProviderWrapper>{wrapped}</ProviderWrapper>;\n    });\n\n    return <>{wrapped}</>;\n  }\n\n  return Provider;\n}\n\n/**\n * Merge State while preserving initial state's sub-objects\n * @param initialState Initial state\n * @param prevState Previous state\n * @param obj New object to be updated\n * @param key State property\n * @returns Merged object\n */\nexport const mergeState = (\n  initialState: { [x: string]: any },\n  prevState: { [x: string]: any },\n  obj: { [x: string]: any } | undefined,\n  key: string\n) => {\n  const newObj = obj\n    ? {\n        ...initialState[key],\n        ...obj,\n      }\n    : prevState[key] || initialState[key];\n\n  return { [key]: newObj };\n};\n"],"mappings":"4ZAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,iBAAAE,EAAA,eAAAC,EAAA,QAAAC,EAAA,qBAAAC,IAAA,eAAAC,EAAAN,GCAA,IAAAO,EAA2D,iBAE3DC,EAAkD,gCAwE5CC,EAAA,6BAhEOC,EACKC,GAChB,CAACC,EAAWC,KAAkB,CAC5B,GAAGD,EACH,CAACD,CAAI,EAAGE,CACV,GAEF,SAASC,EAA2CC,EAA0B,CAC5E,IAAMC,EAAsB,OAAO,OAAO,CAAC,EAAGD,CAAS,EAEvD,cAAO,KAAKA,CAAS,EAAE,QAASE,GAAkB,CAChDD,EAAQC,CAAI,EAAI,IAAY,CAAC,CAC/B,CAAC,EAEMD,CACT,CAQO,SAASE,EACdC,EACAJ,EACa,CACb,IAAMK,KAAU,iBAAc,CAC5BD,EACAL,EAAsBC,CAAS,CACjC,CAAC,EACGC,EAA6B,KAEjC,SAASK,EACPT,EACAU,EAIG,CACH,MAAO,CACL,GAAGV,EACH,GAAGG,EAAUO,EAAO,IAAI,EAAEV,EAAW,GAAIU,EAAO,OAAqB,CACvE,CACF,CAEA,SAASC,EAAS,CAChB,SAAAC,CACF,EAA+C,CAC7C,GAAM,CAACC,EAAOC,CAAQ,KAAI,cAAWL,EAASF,CAAY,EAE1D,OAAAH,KAAU,WAAQ,IAAM,CACtB,IAAMW,EAAqB,OAAO,OAAO,CAAC,EAAGZ,CAAS,EAEtD,cAAO,KAAKA,CAAS,EAAE,QAASE,GAAkB,CAChDU,EAAOV,CAAI,EAAI,IAAIW,IAAe,CAChCF,EAAS,CAAE,KAAMT,EAAM,QAASW,CAAK,CAAC,CACxC,CACF,CAAC,EAEMD,CACT,EAAG,CAACD,CAAQ,CAAC,KAGX,OAACN,EAAQ,SAAR,CAAiB,MAAO,CAACK,EAAOT,CAAO,EAAI,SAAAQ,EAAS,CAEzD,CAEA,SAASK,GAAW,CAClB,SAAO,sBAAmBT,EAAUK,GAAUA,CAAK,CACrD,CAEA,SAASK,EAAaC,EAAe,CAMnC,MAAO,IALO,sBACZX,EACCY,GAAOA,EAAE,CAAC,EAAiBD,CAAI,CAClC,EAEef,CAAO,CACxB,CAEA,MAAO,CAAE,SAAAO,EAAU,SAAAM,EAAU,aAAAC,CAAa,CAC5C,CAOO,SAASG,KACXC,EAC6C,CAChD,SAASX,EAAS,CAChB,SAAAC,CACF,EAA+C,CAC7C,IAAIW,EAAUX,EAEd,OAAAU,EAAO,QAAQ,CAAC,CAAE,SAAUE,CAAgB,IAAM,CAChDD,KAAU,OAACC,EAAA,CAAiB,SAAAD,EAAQ,CACtC,CAAC,KAEM,mBAAG,SAAAA,EAAQ,CACpB,CAEA,OAAOZ,CACT,CAUO,IAAMc,EAAa,CACxBlB,EACAP,EACA0B,EACAC,IACG,CACH,IAAMC,EAASF,EACX,CACE,GAAGnB,EAAaoB,CAAG,EACnB,GAAGD,CACL,EACA1B,EAAU2B,CAAG,GAAKpB,EAAaoB,CAAG,EAEtC,MAAO,CAAE,CAACA,CAAG,EAAGC,CAAO,CACzB","names":["src_exports","__export","createStore","mergeState","set","useStoreProvider","__toCommonJS","import_react","import_use_context_selector","import_jsx_runtime","set","type","prevState","payload","getEmptyActions","mutations","actions","name","createStore","initialState","context","reducer","action","Provider","children","state","dispatch","result","args","useStore","useStoreProp","prop","v","useStoreProvider","stores","wrapped","ProviderWrapper","mergeState","obj","key","newObj"]}