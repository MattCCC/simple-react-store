{"version":3,"sources":["../src/index.ts","../src/store.tsx"],"sourcesContent":["export * from './store';\nexport * from './types/store';","import { useReducer, useMemo, FC, PropsWithChildren } from 'react';\n\nimport { createContext, useContextSelector } from 'use-context-selector';\nimport { Actions, Funct, Mutations, Payload, Store, ValueOf } from './types/store';\n\n/**\n * Toggle state boolean\n * @param {string} type      State key\n * @returns {object}        Modified state\n */\nexport function set<T, T1, T2 = T>(type: keyof T): Funct<T2, T1> {\n  return (prevState, payload): unknown => ({\n    ...prevState,\n    [type]: payload,\n  });\n}\n\nfunction getEmptyActions<S, M extends Mutations<S>>(mutations: M): Actions<M> {\n  const actions: Actions<M> = Object.assign({}, mutations);\n\n  Object.keys(mutations).forEach((name: keyof M) => {\n    actions[name] = (): void => {};\n  });\n\n  return actions;\n}\n\n/**\n * Create a simple store instance with the initial state and reducer\n * @param initialState      Initial store state\n * @param reducer           Reducer to mutate state\n * @returns {Store}         Store instance with `Provider` component and `useStore` hook\n */\nexport function createStore<S, M extends Mutations<S>>(\n  initialState: S,\n  mutations: M\n): Store<S, M> {\n  const defaultContext: [S, Actions<M>] = [\n    initialState,\n    getEmptyActions<S, M>(mutations),\n  ];\n  const context = createContext(defaultContext);\n  let actions: Actions<M> | null = null;\n\n  function reducer(\n    prevState: S,\n    action: {\n      type: keyof M;\n      payload: Payload<M[keyof M]>;\n    }\n  ): S {\n    return {\n      ...prevState,\n      ...mutations[action.type](prevState, ...(action.payload as unknown[])),\n    };\n  }\n\n  function Provider({ children }: PropsWithChildren<Record<string, unknown>>) {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    actions = useMemo(() => {\n      const result: Actions<M> = Object.assign({}, mutations);\n\n      Object.keys(mutations).forEach((name: keyof M) => {\n        result[name] = (...args): void => {\n          dispatch({ type: name, payload: args });\n        };\n      });\n\n      return result;\n    }, [dispatch]);\n\n    const v = [state, actions] as [S, Actions<M>];\n\n    return <context.Provider value={v}>{children}</context.Provider>;\n  }\n\n  function useStore() {\n    return useContextSelector(context, (state) => state);\n  }\n\n  function useStoreProp<K extends keyof S>(prop: K): [S[K], Actions<M>] {\n    const value = useContextSelector(context, (state) => state[0][prop]);\n\n    return [value, actions];\n  }\n\n  return { Provider, useStore, useStoreProp };\n}\n\n/**\n * A custom hook to combine multiple stores and returns a single Provider.\n * @param stores List of stores\n * @returns A single Provider component that provides all the stores\n */\nexport function useStoreProvider(\n  ...stores: Array<Store<unknown, unknown>>\n): FC<PropsWithChildren<Record<string, unknown>>> {\n  function Provider({ children }: PropsWithChildren<Record<string, unknown>>) {\n    let wrapped = children;\n\n    stores.forEach(({ Provider: ProviderWrapper }) => {\n      wrapped = <ProviderWrapper>{wrapped}</ProviderWrapper>;\n    });\n\n    return <>{wrapped}</>;\n  }\n\n  return Provider;\n}\n\n/**\n * Merge State while preserving initial state's sub-objects\n * @param key State property\n * @param initialState Initial state\n * @param prevState Previous state\n * @param obj New object to be updated\n * @returns Merged object\n */\nexport function mergeState<State = { [x: string]: unknown }>(\n  key: keyof State,\n  initialState: State,\n  prevState: State,\n  obj: Partial<ValueOf<State, typeof key>> | undefined\n): State {\n  const newObj = obj || prevState[key] || initialState[key];\n\n  return { ...prevState, ...{ [key]: newObj } };\n}\n"],"mappings":"4ZAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,iBAAAE,EAAA,eAAAC,EAAA,QAAAC,EAAA,qBAAAC,IAAA,eAAAC,EAAAN,GCAA,IAAAO,EAA2D,iBAE3DC,EAAkD,gCAwEvCC,EAAA,6BAhEJ,SAASC,EAAmBC,EAA8B,CAC/D,MAAO,CAACC,EAAWC,KAAsB,CACvC,GAAGD,EACH,CAACD,CAAI,EAAGE,CACV,EACF,CAEA,SAASC,EAA2CC,EAA0B,CAC5E,IAAMC,EAAsB,OAAO,OAAO,CAAC,EAAGD,CAAS,EAEvD,cAAO,KAAKA,CAAS,EAAE,QAASE,GAAkB,CAChDD,EAAQC,CAAI,EAAI,IAAY,CAAC,CAC/B,CAAC,EAEMD,CACT,CAQO,SAASE,EACdC,EACAJ,EACa,CACb,IAAMK,EAAkC,CACtCD,EACAL,EAAsBC,CAAS,CACjC,EACMM,KAAU,iBAAcD,CAAc,EACxCJ,EAA6B,KAEjC,SAASM,EACPV,EACAW,EAIG,CACH,MAAO,CACL,GAAGX,EACH,GAAGG,EAAUQ,EAAO,IAAI,EAAEX,EAAW,GAAIW,EAAO,OAAqB,CACvE,CACF,CAEA,SAASC,EAAS,CAAE,SAAAC,CAAS,EAA+C,CAC1E,GAAM,CAACC,EAAOC,CAAQ,KAAI,cAAWL,EAASH,CAAY,EAE1DH,KAAU,WAAQ,IAAM,CACtB,IAAMY,EAAqB,OAAO,OAAO,CAAC,EAAGb,CAAS,EAEtD,cAAO,KAAKA,CAAS,EAAE,QAASE,GAAkB,CAChDW,EAAOX,CAAI,EAAI,IAAIY,IAAe,CAChCF,EAAS,CAAE,KAAMV,EAAM,QAASY,CAAK,CAAC,CACxC,CACF,CAAC,EAEMD,CACT,EAAG,CAACD,CAAQ,CAAC,EAEb,IAAMG,EAAI,CAACJ,EAAOV,CAAO,EAEzB,SAAO,OAACK,EAAQ,SAAR,CAAiB,MAAOS,EAAI,SAAAL,EAAS,CAC/C,CAEA,SAASM,GAAW,CAClB,SAAO,sBAAmBV,EAAUK,GAAUA,CAAK,CACrD,CAEA,SAASM,EAAgCC,EAA6B,CAGpE,MAAO,IAFO,sBAAmBZ,EAAUK,GAAUA,EAAM,CAAC,EAAEO,CAAI,CAAC,EAEpDjB,CAAO,CACxB,CAEA,MAAO,CAAE,SAAAQ,EAAU,SAAAO,EAAU,aAAAC,CAAa,CAC5C,CAOO,SAASE,KACXC,EAC6C,CAChD,SAASX,EAAS,CAAE,SAAAC,CAAS,EAA+C,CAC1E,IAAIW,EAAUX,EAEd,OAAAU,EAAO,QAAQ,CAAC,CAAE,SAAUE,CAAgB,IAAM,CAChDD,KAAU,OAACC,EAAA,CAAiB,SAAAD,EAAQ,CACtC,CAAC,KAEM,mBAAG,SAAAA,EAAQ,CACpB,CAEA,OAAOZ,CACT,CAUO,SAASc,EACdC,EACApB,EACAP,EACA4B,EACO,CACP,IAAMC,EAASD,GAAO5B,EAAU2B,CAAG,GAAKpB,EAAaoB,CAAG,EAExD,MAAO,CAAE,GAAG3B,EAAgB,CAAC2B,CAAG,EAAGE,CAAS,CAC9C","names":["src_exports","__export","createStore","mergeState","set","useStoreProvider","__toCommonJS","import_react","import_use_context_selector","import_jsx_runtime","set","type","prevState","payload","getEmptyActions","mutations","actions","name","createStore","initialState","defaultContext","context","reducer","action","Provider","children","state","dispatch","result","args","v","useStore","useStoreProp","prop","useStoreProvider","stores","wrapped","ProviderWrapper","mergeState","key","obj","newObj"]}